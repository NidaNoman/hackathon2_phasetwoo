# Implementation Plan: Phase-2 Todo Web Application

**Branch**: `001-todo-web-app` | **Date**: 2026-01-10 | **Spec**: [specs/001-todo-web-app/spec.md](specs/001-todo-web-app/spec.md)
**Input**: Feature specification from `specs/001-todo-web-app/spec.md`

## Summary

This plan outlines the technical approach to implement the Phase-2 Todo Web Application, transforming the CLI todo functionality into a multi-user, full-stack web application. It leverages a monorepo structure with a clear separation of frontend (Next.js) and backend (FastAPI), secure JWT-based authentication, and persistent data storage using SQLModel with Neon Serverless PostgreSQL. The plan details the monorepo layout, responsibilities of each service, authentication and API communication flows, and database access patterns.

## Technical Context

**Language/Version**: Python 3.11+ (Backend) and TypeScript 5.x+ (Frontend)
**Primary Dependencies**: FastAPI, SQLModel, Pydantic (Backend); Next.js (App Router), React, Better Auth (JWT libraries) (Frontend); Alembic (Database Migrations)
**Storage**: Neon Serverless PostgreSQL (Production), SQLite (Development)
**Testing**: pytest with pytest-asyncio (Backend); Jest and React Testing Library (Frontend)
**Target Platform**: Web (Browser for Frontend, Containerized Linux for Backend deployment)
**Project Type**: Monorepo containing separated web application (frontend + backend) and the unchanged Phase-1 CLI application.
**Performance Goals**:
-   SC-002: 99% of authenticated API requests achieve a response time of less than 500ms under typical load conditions (e.g., 100 concurrent users).
-   SC-005: User task lists MUST load and display within 2 seconds for a user with up to 100 active tasks.
**Constraints**:
-   SC-004: Any attempt by an unauthenticated user or a user trying to access another user's tasks MUST consistently result in a `401 Unauthorized` or `403 Forbidden` HTTP response.
-   SC-006: After a task is created, updated, or deleted, the changes MUST be immediately reflected in the user's task list upon refresh.
**Scale/Scope**: Multi-user todo application, supporting individual task management for an anticipated 1,000 active users.

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

-   **Principle: Spec-Driven Development ONLY**: PASSED. This plan is derived directly from the approved `specs/001-todo-web-app/spec.md`.
-   **Principle: No Manual Coding by Humans**: PASSED. All code will be generated by agents following this plan and subsequent tasks.
-   **Principle: Monorepo Architecture**: PASSED. The plan explicitly details a monorepo structure.
-   **Principle: Frontend and Backend Separated**: PASSED. The plan defines distinct frontend and backend services with API communication.
-   **Principle: JWT-based Authentication Mandatory**: PASSED. The plan incorporates JWT-based authentication.
-   **Principle: User Data Isolation is Critical**: PASSED. The plan emphasizes and outlines mechanisms for user data isolation.
-   **Principle: Phase-1 Code Must Remain Unchanged**: PASSED. The plan explicitly isolates Phase-1 code, ensuring no modifications.
-   **Principle: Approved Stack Usage**: PASSED. The plan strictly adheres to Next.js App Router + TypeScript, FastAPI, SQLModel, Neon Serverless PostgreSQL, and Better Auth (JWT).

## Project Structure

This project will utilize a monorepo structure to house the frontend, backend, and the existing Phase-1 CLI application.

### Documentation (this feature)

```text
specs/001-todo-web-app/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
.
├── phase1-cli/          # Existing Phase-1 CLI application (unchanged)
├── frontend/            # Next.js application
│   ├── public/
│   ├── src/
│   │   ├── app/         # Next.js App Router pages, layouts, etc.
│   │   ├── components/  # Reusable React components
│   │   ├── lib/         # Utility functions, API clients
│   │   └── types/       # Shared TypeScript types (symlinked or copied from packages/types)
│   ├── tests/
│   └── package.json
├── backend/             # FastAPI application
│   ├── app/
│   │   ├── api/         # API endpoints (routers)
│   │   ├── core/        # Configuration, settings, security (JWT)
│   │   ├── crud/        # Create, Read, Update, Delete operations
│   │   ├── db/          # Database session, models (SQLModel)
│   │   ├── models/      # Pydantic models for request/response, SQLModel ORM models
│   │   └── services/    # Business logic services
│   ├── tests/
│   ├── migrations/      # Alembic migration scripts
│   └── requirements.txt
├── packages/            # Shared packages (e.g., common types, utilities)
│   └── types/           # TypeScript and Python shared type definitions
│       ├── python/      # Python type definitions (e.g., Pydantic models for API)
│       └── typescript/  # TypeScript type definitions (e.g., interfaces for frontend)
└── .env.example         # Template for environment variables

```

**Structure Decision**: The "Web application (frontend + backend)" option is chosen as the base, extended with a `packages/types` directory for shared type definitions, enabling robust type-checking across the monorepo. The existing `phase1-cli/` directory remains untouched at the root level. This structure supports clean separation of concerns, independent development/deployment of frontend and backend, and facilitates type sharing.

## Technical Details

### Frontend Responsibilities (Next.js App Router + TypeScript)
-   **User Interface**: Render all UI components based on React.
-   **Routing**: Manage client-side navigation using Next.js App Router.
-   **Authentication**: Handle user login/logout, store/manage JWT tokens securely (e.g., HTTP-only cookies).
-   **API Communication**: Interact with the backend FastAPI application via HTTP requests using a type-safe API client (generated from OpenAPI spec or manually defined with shared types).
-   **Data Display/Manipulation**: Fetch, display, and manage todo task data for the authenticated user.
-   **Input Validation**: Client-side validation of user input before sending to backend.

### Backend Responsibilities (FastAPI + SQLModel)
-   **RESTful API**: Expose API endpoints for user authentication (signup, login) and CRUD operations for tasks.
-   **Authentication**: Validate JWT tokens for all protected endpoints.
-   **Authorization**: Implement logic to ensure users can only access/modify their own tasks.
-   **Business Logic**: Contain core logic for managing tasks and users.
-   **Data Persistence**: Interact with Neon Serverless PostgreSQL using SQLModel for ORM operations and database schema management (via Alembic).
-   **Input Validation**: Server-side validation of all incoming request data using Pydantic models.
-   **Security**: Handle password hashing, JWT token generation and validation.

### Authentication Flow (Better Auth + JWT)
1.  **User Registration**:
    *   Frontend sends username and password to `/backend/app/api/auth/register`.
    *   Backend hashes password (using a strong, modern hashing algorithm like bcrypt), creates a new user record in the database via SQLModel.
    *   Backend generates a JWT containing user ID and other necessary claims.
    *   JWT is returned to the frontend (e.g., as an HTTP-only cookie or in the response body for storage in memory/local storage, with HTTP-only cookies preferred for security).
2.  **User Login**:
    *   Frontend sends username and password to `/backend/app/api/auth/login`.
    *   Backend verifies credentials against hashed password in the database.
    *   Upon successful verification, a JWT is generated and returned to the frontend.
3.  **Authenticated Requests**:
    *   Frontend includes the JWT in the `Authorization` header (`Bearer <token>`) for all protected API calls to the backend.
    *   Backend middleware or dependency (FastAPI Depends) validates the JWT, extracts the user ID, and makes it available to the endpoint handlers.
    *   Authorization logic in endpoint handlers verifies if the authenticated user has permission for the requested resource (e.g., `owner_id` matches `current_user_id`).

### API Communication Flow
-   The frontend will make HTTP requests (GET, POST, PUT, DELETE) to the backend's RESTful API endpoints.
-   Requests will be authenticated via JWT in the `Authorization: Bearer <token>` header.
-   API endpoints will be defined using FastAPI's routing system.
-   Request and response bodies will be JSON, validated using Pydantic models on the backend and corresponding TypeScript interfaces/types on the frontend (potentially shared via `packages/types`).

### Database Access Pattern using SQLModel
-   SQLModel will be used as the ORM for interacting with the Neon Serverless PostgreSQL database.
-   Database models (`User`, `Task`) will be defined using SQLModel, inheriting from `SQLModel`.
-   CRUD operations will be encapsulated within backend services (`crud/` directory) that use SQLModel sessions to perform database operations.
-   Alembic will be used for database migrations to manage schema changes.
-   Database session management will ensure proper connection handling and transaction control.

### Environment Variables Strategy
-   Sensitive information (database URLs, JWT secrets, API keys, etc.) MUST be stored in environment variables.
-   A `.env.example` file (not `.env`) will be committed to the repository, outlining all required environment variables with placeholder values.
-   During development, a local `.env` file (excluded from version control) will be used.
-   In deployment environments, environment variables will be set via the platform's configuration mechanisms (e.g., Docker secrets, Kubernetes secrets, PaaS environment variables).
-   FastAPI's `Settings` management (e.g., using Pydantic BaseSettings) will be used to load and manage environment variables in a type-safe manner.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|---|---|---|
| | | |