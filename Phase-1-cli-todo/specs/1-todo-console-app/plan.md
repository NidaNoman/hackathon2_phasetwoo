# Implementation Plan: Phase 1 Todo Console App

**Branch**: `1-todo-console-app` | **Date**: 2025-12-31 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/1-todo-console-app/spec.md`

**Note**: This plan is generated by the `/sp.plan` command following SDD workflow.

## Summary

Build a console-based todo task manager demonstrating Spec-Driven Development with AI agent (Claude Code) as sole implementer. The application provides CRUD operations (Create, Read, Update status, Delete) for todo tasks with in-memory storage only. Key focus: TDD methodology, clean architecture with separated concerns (models, repository, services, CLI), and strict adherence to Constitution principles (Python 3.13+, no persistence, console UI only).

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Standard library (dataclasses, datetime, enum) + rich (console formatting) + pytest (testing) + mypy (type checking) + ruff (linting)
**Storage**: In-memory only (dict-based repository with auto-increment IDs) - NO databases, NO files
**Testing**: pytest with ≥80% coverage, mypy strict mode, ruff linting
**Target Platform**: Cross-platform console (Windows/Linux/macOS terminals)
**Project Type**: Single standalone Python application
**Performance Goals**: <2s startup, <500ms operations with 100 tasks, <500MB memory with 500 tasks
**Constraints**: Python 3.13+ only, in-memory storage, console UI, TDD mandatory, Claude Code sole implementer
**Scale/Scope**: Single-user, 500 tasks typical usage, educational/demonstration project for Phase 1

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**✅ Spec-Driven Development (Principle I)**:
- ✅ Specification complete: spec.md created and validated
- ✅ Architectural planning: plan.md (this file) defines design decisions
- ✅ Task decomposition: tasks.md created with 65 discrete tasks
- ✅ No manual coding: Claude Code will be sole implementer

**✅ AI Agent as Sole Implementer (Principle II)**:
- ✅ Claude Code designated as exclusive code generator
- ✅ Human role: architect, reviewer, decision maker (no coding)
- ✅ All code changes through SDD artifacts

**✅ Test-First Development (Principle III)**:
- ✅ TDD mandatory: 24 test tasks in tasks.md (write tests FIRST)
- ✅ Red-Green-Refactor cycle enforced in task order
- ✅ Test cases defined before implementation tasks

**✅ Python 3.13+ Only (Principle IV)**:
- ✅ Language version: Python 3.13+
- ✅ Type hints: Complete annotations with mypy strict mode
- ✅ Modern features: dataclasses, match statements, type hints
- ✅ Standard library preferred: Minimal external dependencies

**✅ In-Memory Storage Only (Principle V)**:
- ✅ Storage: dict-based InMemoryTaskRepository
- ✅ NO databases: Confirmed - no SQLite, PostgreSQL, etc.
- ✅ NO files: Confirmed - no JSON, CSV, pickle files
- ✅ State resets on restart: Expected behavior documented

**✅ Console-Based UI Only (Principle VI)**:
- ✅ UI: Console/terminal with stdin/stdout
- ✅ Formatting: rich library for tables and colors
- ✅ NO web interfaces: Confirmed - no Flask, FastAPI, etc.
- ✅ NO GUI: Confirmed - no tkinter, PyQt, etc.

**✅ Simplicity and Minimalism (Principle VII)**:
- ✅ YAGNI: Only specified requirements in scope
- ✅ Function length: Max 50 lines (excluding docstrings)
- ✅ Clear code: Readable over clever
- ✅ Single Responsibility: Each module has focused purpose

**Constitution Compliance**: ✅ PASS - All 7 principles satisfied

## Project Structure

### Documentation (this feature)

```text
specs/1-todo-console-app/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file - implementation plan
├── tasks.md             # 65 implementation tasks (complete)
├── research.md          # Phase 0 - design decisions (to be created)
├── data-model.md        # Phase 1 - entity definitions (to be created)
├── quickstart.md        # Phase 1 - usage guide (to be created)
└── checklists/
    └── requirements.md  # Spec quality validation (complete)
```

### Source Code (repository root)

```text
# Single project structure (per Constitution)
src/
├── models/
│   └── task.py          # Task entity, TaskStatus enum
├── repositories/
│   ├── task_repository.py        # Repository interface (ABC)
│   └── in_memory_repository.py   # Dict-based implementation
├── services/
│   └── task_service.py  # Business logic (CRUD operations)
├── commands/
│   ├── add_task.py      # Add task command handler
│   ├── view_tasks.py    # View tasks command handler
│   ├── update_task.py   # Update task command handler
│   ├── delete_task.py   # Delete task command handler
│   ├── toggle_status.py # Toggle status command handler
│   └── exit_app.py      # Exit command handler
├── ui/
│   ├── console.py       # Console UI helpers (menu, input, display)
│   └── formatters.py    # Task display formatting (tables, colors)
├── utils/
│   └── validators.py    # Input validation functions
└── main.py              # Application entry point, main loop

tests/
├── unit/
│   ├── test_task_model.py      # Task entity tests
│   ├── test_repository.py      # Repository tests
│   ├── test_validators.py      # Validator tests
│   ├── test_console.py         # Console helper tests
│   └── test_task_service.py    # Service layer tests
└── integration/
    ├── test_add_task.py         # Add task workflow tests
    ├── test_view_tasks.py       # View tasks workflow tests
    ├── test_update_task.py      # Update task workflow tests
    ├── test_delete_task.py      # Delete task workflow tests
    ├── test_toggle_status.py    # Toggle status workflow tests
    ├── test_exit.py             # Exit workflow tests
    └── test_full_workflow.py    # End-to-end integration test

# Configuration files (repository root)
pyproject.toml           # Project dependencies and tool configuration
.gitignore               # Python ignores (__pycache__, *.pyc, etc.)
README.md                # Project overview and setup instructions
```

**Structure Decision**: Single project structure chosen per Constitution (no backend/frontend split, no mobile). Simple flat hierarchy with clear separation of concerns: models (data), repositories (storage), services (business logic), commands (use cases), UI (presentation), utils (helpers).

## Complexity Tracking

> **No complexity violations** - Constitution Check passed all gates. Simple architecture aligns with Principle VII (Simplicity and Minimalism).

---

## Phase 0: Research & Design Decisions

**Status**: To be created in `research.md`

**Purpose**: Document architectural decisions and resolve any technical uncertainties.

### Key Design Decisions

1. **Data Structure for Task Storage**
   - **Decision**: Dict[int, Task] with separate counter for auto-increment IDs
   - **Rationale**: O(1) lookup by ID, simple implementation, no external dependencies
   - **Alternatives Considered**: List with linear search (O(n) lookup), ordered dict (unnecessary ordering guarantees)

2. **Console UI Library Choice**
   - **Decision**: Use `rich` library for tables, colors, and formatting
   - **Rationale**: Rich provides excellent console rendering, widely used, simple API
   - **Alternatives Considered**: colorama (less feature-rich), blessed (more complex), plain text (poor UX)

3. **Command Pattern for Menu Options**
   - **Decision**: Separate command handler modules (add_task.py, view_tasks.py, etc.)
   - **Rationale**: Single Responsibility Principle, easy testing, clear separation of concerns
   - **Alternatives Considered**: Single monolithic menu handler (violates SRP), class-based commands (unnecessary complexity)

4. **Repository Pattern for Storage Abstraction**
   - **Decision**: TaskRepository ABC with InMemoryTaskRepository implementation
   - **Rationale**: Testability (mock repository), future extensibility (Phase 2 could add file storage)
   - **Alternatives Considered**: Direct dict access (tight coupling), global state (testing difficulties)

5. **Status Representation**
   - **Decision**: Enum TaskStatus with PENDING and COMPLETE values
   - **Rationale**: Type safety, explicit states, prevents invalid values
   - **Alternatives Considered**: Boolean completed field (less explicit), string status (no type safety)

6. **ID Assignment Strategy**
   - **Decision**: Sequential auto-increment starting from 1, no ID reuse within session
   - **Rationale**: Simple, predictable, user-friendly (no UUIDs), meets spec requirements
   - **Alternatives Considered**: UUID (overkill for single-user), timestamp-based (not user-friendly)

7. **Error Handling Strategy**
   - **Decision**: Validate at entry points (commands), raise ValueError for invalid operations
   - **Rationale**: Fail fast, clear error messages, prevent invalid state
   - **Alternatives Considered**: Return None/Optional (silent failures), error codes (not Pythonic)

8. **Test Organization**
   - **Decision**: Unit tests for isolated components, integration tests for workflows
   - **Rationale**: Fast unit tests for development, integration tests for user scenarios
   - **Alternatives Considered**: Only integration tests (slow feedback loop), only unit tests (miss integration issues)

---

## Phase 1: Data Model & Contracts

**Status**: To be created in `data-model.md` and `quickstart.md`

### Entity: Task

**Purpose**: Represents a single todo item with all attributes and behavior.

**Fields**:
- `id: int` - Unique identifier, auto-assigned, immutable, starts from 1
- `title: str` - Task title (1-100 characters, required)
- `description: str` - Detailed description (1-500 characters, required)
- `completed: bool` - Completion status (default: False)
- `created_at: datetime` - Timestamp of creation (auto-assigned, immutable)

**Validation Rules**:
- Title: Non-empty, ≤100 characters, no leading/trailing whitespace
- Description: Non-empty, ≤500 characters, no leading/trailing whitespace
- ID: Positive integer, unique across active tasks
- Completed: Boolean only (True/False)

**State Transitions**:
- New task: completed = False (PENDING)
- Toggle: False ↔ True (PENDING ↔ COMPLETE)
- No other state changes allowed

**Immutable Fields**: id, created_at (cannot change after creation)
**Mutable Fields**: title, description, completed (can be updated)

### Repository: TaskRepository (Interface)

**Purpose**: Abstract storage interface for task persistence.

**Methods**:
- `add(task: Task) -> Task` - Store new task, return task with assigned ID
- `get_by_id(task_id: int) -> Task | None` - Retrieve task by ID, return None if not found
- `get_all() -> list[Task]` - Retrieve all tasks, return empty list if none
- `update(task: Task) -> Task` - Update existing task, raise ValueError if ID not found
- `delete(task_id: int) -> bool` - Delete task by ID, return True if deleted, False if not found
- `exists(task_id: int) -> bool` - Check if task ID exists

### Repository: InMemoryTaskRepository (Implementation)

**Purpose**: In-memory implementation using dict storage.

**Internal State**:
- `_tasks: dict[int, Task]` - Storage dict mapping ID to Task
- `_next_id: int` - Counter for auto-increment IDs (starts at 1)

**Behavior**:
- IDs assigned sequentially (1, 2, 3, ...)
- No ID reuse within same session (even after delete)
- All operations O(1) time complexity for ID-based access
- get_all() returns tasks in insertion order (dict preserves order in Python 3.7+)

### Service: TaskService

**Purpose**: Business logic layer orchestrating repository operations and validation.

**Methods**:
- `create_task(title: str, description: str) -> Task`
  - Validates title and description
  - Creates Task entity
  - Persists via repository
  - Returns created task with assigned ID

- `get_task(task_id: int) -> Task`
  - Retrieves task by ID
  - Raises ValueError if not found

- `get_all_tasks() -> list[Task]`
  - Returns all tasks
  - Empty list if no tasks

- `update_task(task_id: int, title: str, description: str) -> Task`
  - Validates inputs
  - Updates existing task
  - Raises ValueError if ID not found

- `toggle_task_status(task_id: int) -> Task`
  - Toggles completed field (True ↔ False)
  - Raises ValueError if ID not found

- `delete_task(task_id: int) -> bool`
  - Deletes task by ID
  - Returns True if deleted, False if not found

### Commands (CLI Handlers)

**Purpose**: Handle user interactions for each menu option.

**Command Modules**:

1. **add_task.py**:
   - Prompt for title
   - Prompt for description
   - Validate inputs (delegate to validators.py)
   - Call TaskService.create_task()
   - Display confirmation with assigned ID

2. **view_tasks.py**:
   - Call TaskService.get_all_tasks()
   - Format tasks as table (delegate to formatters.py)
   - Display "No tasks found" if empty
   - Show ID, Title, Description (truncated), Status

3. **update_task.py**:
   - Prompt for task ID
   - Validate ID exists
   - Prompt for new title
   - Prompt for new description
   - Call TaskService.update_task()
   - Display confirmation

4. **delete_task.py**:
   - Prompt for task ID
   - Validate ID exists
   - Confirm deletion (y/n)
   - Call TaskService.delete_task()
   - Display confirmation

5. **toggle_status.py**:
   - Prompt for task ID
   - Validate ID exists
   - Call TaskService.toggle_task_status()
   - Display confirmation with old → new status

6. **exit_app.py**:
   - Display data loss warning
   - Confirm exit (y/n)
   - Display goodbye message
   - Return exit signal to main loop

### UI Components

**console.py** - Console interaction helpers:
- `display_menu()` - Show main menu with numbered options
- `get_user_input(prompt: str) -> str` - Get text input from user
- `get_user_choice(prompt: str, min_val: int, max_val: int) -> int` - Get validated numeric choice
- `display_message(message: str, style: str)` - Display styled message (info, success, error, warning)
- `clear_screen()` - Clear console (optional, for cleaner UX)

**formatters.py** - Task display formatting:
- `format_task_table(tasks: list[Task]) -> Table` - Create rich Table with task data
- `format_task_status(completed: bool) -> str` - Format status with icon (✓ COMPLETE / ○ PENDING)
- `truncate_text(text: str, max_length: int) -> str` - Truncate long descriptions with ellipsis

### Main Application Loop

**main.py** - Entry point and menu dispatcher:

```python
def main() -> None:
    """Main application loop."""
    repository = InMemoryTaskRepository()
    service = TaskService(repository)

    while True:
        display_menu()
        choice = get_user_choice("Select option (1-6): ", 1, 6)

        match choice:
            case 1: add_task_command(service)
            case 2: view_tasks_command(service)
            case 3: update_task_command(service)
            case 4: delete_task_command(service)
            case 5: toggle_status_command(service)
            case 6:
                if exit_app_command():
                    break
```

**Menu Options**:
1. Add Task
2. View Tasks
3. Update Task
4. Delete Task
5. Toggle Task Status
6. Exit

---

## Component Responsibilities

### Models (`src/models/`)

**Responsibility**: Define data structures and business entities.

**task.py**:
- `Task` dataclass with fields: id, title, description, completed, created_at
- `TaskStatus` enum: PENDING, COMPLETE
- No business logic (pure data)
- Type hints on all fields
- `__str__` and `__repr__` for debugging

### Repositories (`src/repositories/`)

**Responsibility**: Abstract storage operations, provide data access layer.

**task_repository.py**:
- `TaskRepository` ABC defining interface
- All methods abstract
- Type hints on all signatures

**in_memory_repository.py**:
- `InMemoryTaskRepository` implementing TaskRepository
- Dict-based storage with auto-increment IDs
- All CRUD operations
- Thread-safe not required (single-user)

### Services (`src/services/`)

**Responsibility**: Business logic, orchestrate repository and validation.

**task_service.py**:
- `TaskService` class
- Depends on TaskRepository (dependency injection)
- Validates inputs before repository calls
- Handles business rules (e.g., toggle status logic)
- Raises clear exceptions for invalid operations

### Commands (`src/commands/`)

**Responsibility**: Handle specific user actions, UI interaction logic.

**Each command module**:
- Single command handler function
- Takes TaskService as parameter
- Handles prompts, validation, error display
- Calls appropriate service methods
- Displays results to user
- No business logic (delegate to service)

### UI (`src/ui/`)

**Responsibility**: Console rendering and user input handling.

**console.py**:
- Generic UI helpers (menu, input, messages)
- No business logic
- No task-specific knowledge

**formatters.py**:
- Task-specific display formatting
- Rich library integration
- Table creation, status icons

### Utils (`src/utils/`)

**Responsibility**: Shared utilities and validation functions.

**validators.py**:
- `validate_title(title: str) -> None` - Raises ValueError if invalid
- `validate_description(desc: str) -> None` - Raises ValueError if invalid
- `validate_positive_int(value: str) -> int` - Parse and validate integer input
- Pure functions, no state

### Main (`src/main.py`)

**Responsibility**: Application entry point, main loop, dependency wiring.

- Creates repository and service instances
- Runs main menu loop
- Dispatches to command handlers
- Handles top-level exceptions
- Startup and shutdown logic

---

## Testing Strategy

### Unit Tests (`tests/unit/`)

**Purpose**: Test isolated components with no external dependencies.

**Coverage**:
- **test_task_model.py**: Task dataclass creation, validation, immutability
- **test_repository.py**: InMemoryTaskRepository CRUD operations, edge cases
- **test_validators.py**: All validation functions, boundary conditions
- **test_console.py**: UI helper functions (mocked I/O)
- **test_task_service.py**: Service methods with mocked repository

**Approach**:
- Arrange-Act-Assert pattern
- Use pytest fixtures for common setup
- Mock external dependencies (repository in service tests)
- Fast execution (<1s for all unit tests)

### Integration Tests (`tests/integration/`)

**Purpose**: Test complete workflows end-to-end.

**Coverage**:
- **test_add_task.py**: Full add task workflow with real repository
- **test_view_tasks.py**: View tasks with various states (empty, populated, mixed status)
- **test_update_task.py**: Update task workflow, error cases
- **test_delete_task.py**: Delete task workflow, verify removal
- **test_toggle_status.py**: Toggle status workflow, idempotency
- **test_exit.py**: Exit command, data loss warning
- **test_full_workflow.py**: Complete user journey (add → view → update → toggle → delete → exit)

**Approach**:
- Fresh repository for each test (isolation)
- Test Given-When-Then scenarios from spec.md
- Validate error messages and edge cases
- Slower execution acceptable (comprehensive coverage)

### Test-Driven Development (TDD) Workflow

**Red-Green-Refactor Cycle** (per Constitution Principle III):

1. **RED Phase**: Write failing test
   - Define expected behavior
   - Test fails (no implementation yet)
   - Commit test

2. **GREEN Phase**: Implement minimal code to pass test
   - Write simplest implementation
   - Test passes
   - Commit implementation

3. **REFACTOR Phase**: Improve code quality
   - Clean up duplication
   - Improve naming
   - Tests still pass
   - Commit refactor

**Example - Task Model**:
1. RED: Write test_task_creation() expecting Task with fields
2. GREEN: Create Task dataclass with fields
3. REFACTOR: Add type hints, docstrings

**Example - Add Task Command**:
1. RED: Write test_add_task_success() expecting task created with ID
2. GREEN: Implement add_task_command() calling service
3. REFACTOR: Extract validation, improve error handling

---

## Quality Gates

**All gates MUST pass before task completion:**

### Type Checking (mypy strict)
```bash
mypy src/ tests/ --strict
```
**Requirements**:
- All functions have type hints
- No Any types (except where unavoidable)
- No implicit Optional
- Strict mode passes with 0 errors

### Linting (ruff)
```bash
ruff check src/ tests/
```
**Requirements**:
- No linting violations
- Follow PEP 8 conventions
- Max line length: 100 characters
- Max function length: 50 lines (excluding docstrings)

### Testing (pytest with coverage)
```bash
pytest tests/ --cov=src --cov-report=term-missing --cov-report=html
```
**Requirements**:
- All tests pass (0 failures)
- Coverage ≥80% for src/
- No skipped tests (unless explicitly justified)
- Fast execution (<10s for full suite)

### Documentation
**Requirements**:
- Docstrings on all public functions (Google style)
- Type hints on all function signatures
- README.md with setup and usage instructions
- Code is self-documenting (clear names)

---

## Implementation Sequence

**Recommended order** (from tasks.md):

### Phase 1: Setup (Tasks T001-T007)
- Create project structure
- Initialize pyproject.toml with dependencies
- Configure mypy, ruff, pytest
- Create .gitignore and README.md

### Phase 2: Foundational (Tasks T008-T017) ⚠️ BLOCKING
- **TDD**: Write unit tests FIRST for each component
- Create Task model and TaskStatus enum
- Implement TaskRepository interface and InMemoryTaskRepository
- Create validators module
- Create console UI helpers

**CHECKPOINT**: All foundational tests pass, foundation ready for user stories

### Phase 3-8: User Stories (Tasks T018-T054)
**MVP First** (fastest path to working app):
- Phase 3: US1 - Add Task (T018-T023)
- Phase 4: US2 - View Tasks (T024-T030)
- Phase 8: US6 - Exit (T049-T054)

**CHECKPOINT**: Working app with add, view, exit functionality

**Full Feature Set**:
- Phase 7: US5 - Toggle Status (T043-T048)
- Phase 6: US4 - Delete Task (T037-T042)
- Phase 5: US3 - Update Task (T031-T036)

**CHECKPOINT**: All CRUD operations complete

### Phase 9: Polish (Tasks T055-T065)
- Add comprehensive docstrings
- Run quality gates (mypy, ruff, coverage)
- Create end-to-end integration test
- Update README with usage examples
- Performance and edge case testing

**CHECKPOINT**: Production-ready, all quality gates pass

---

## Risk Assessment & Mitigation

### Risk 1: Type Checking Complexity
**Likelihood**: Medium | **Impact**: Low
**Description**: mypy strict mode may require complex type annotations for dynamic code
**Mitigation**: Keep code simple, avoid dynamic features, use type: ignore sparingly with justification

### Risk 2: Test Coverage Gaps
**Likelihood**: Low | **Impact**: Medium
**Description**: Integration tests may miss edge cases, unit tests may not cover integration issues
**Mitigation**: TDD workflow ensures tests written first, review coverage reports, add tests for uncovered branches

### Risk 3: Console UI Limitations
**Likelihood**: Low | **Impact**: Low
**Description**: Rich library may not render correctly in all terminals
**Mitigation**: Test on multiple terminals (Windows CMD, PowerShell, Linux bash), fallback to plain text if rendering fails

### Risk 4: Performance with Large Task Lists
**Likelihood**: Medium | **Impact**: Low
**Description**: Viewing 500+ tasks may be slow or overwhelming
**Mitigation**: Dict storage provides O(1) lookup, consider pagination if needed (out of scope for Phase 1)

### Risk 5: Scope Creep
**Likelihood**: Medium | **Impact**: High
**Description**: Temptation to add features beyond spec (task editing, categories, etc.)
**Mitigation**: Strict adherence to Constitution Principle VII (YAGNI), refer to spec.md for scope boundaries

---

## Success Criteria (from spec.md)

**Application must meet all success criteria**:

- ✅ SC-001: Task creation in <5 seconds
- ✅ SC-002: View 100 tasks in <2 seconds
- ✅ SC-003: Mark complete in <3 seconds
- ✅ SC-004: Delete task in <3 seconds
- ✅ SC-005: Clear error messages for invalid input
- ✅ SC-006: Startup in <2 seconds
- ✅ SC-007: Responsive with 500 tasks
- ✅ SC-008: First-attempt workflow success

**Quality Gates**:
- ✅ All tests pass (pytest)
- ✅ Type checking pass (mypy strict)
- ✅ Linting pass (ruff)
- ✅ Coverage ≥80%
- ✅ Documentation complete

---

## Next Steps

1. ✅ Plan complete (this file)
2. ⏭ Create research.md with detailed design decisions
3. ⏭ Create data-model.md with entity specifications
4. ⏭ Create quickstart.md with usage examples
5. ⏭ Begin implementation following tasks.md (Phase 1: Setup)
6. ⏭ TDD workflow: Write tests FIRST for each component
7. ⏭ Iterative development: Complete MVP → Full features → Polish

**Ready for implementation**: All architectural decisions made, structure defined, responsibilities clear.
